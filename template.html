<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>职业教育 | Qimo</title>
    <style>
        :root {
            --bg-body: #f9f8f6;
            --bg-card: #ffffff;
            --bg-block: #f4f4f2;

            --text-main: #333333;
            --text-sub: #888888;
            --text-accent: #5e7087;

            --border-light: #f0f0f0;
            --radius: 6px;
            --spacing: 28px;

            /* 字体栈 */
            --font-serif: "Songti SC", "Noto Serif SC", "SimSun", "Times New Roman", serif;
            --font-sans: -apple-system, BlinkMacSystemFont, "PingFang SC", "Microsoft YaHei", sans-serif;

            /* 基础字号变量，默认 15px */
            --base-font-size: 15px;

            /* 阅读进度（用于悬浮条背景进度条） */
            --read-progress: 0%;

            /* 代码/高亮 token（默认：亮色主题） */
            --code-bg: #ffffff;
            --code-border: #e0e0e0;
            --code-demicode: #15658f;
            --code-orange: rgb(151, 80, 13);
            --code-blue: rgb(8, 56, 93);
            --code-purple: rgb(112, 31, 146);

            /* 悬浮条/小球（默认：亮色主题） */
            --bar-bg: rgba(255, 255, 255, 0.85);
            --bar-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            --bar-border: transparent;
            --bar-progress-strength: 16%;
            --bar-progress-fallback-alpha: 0.10;

            --ball-bg: rgba(255, 255, 255, 0.78);
            --ball-border: rgba(0, 0, 0, 0.06);
            --ball-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            --ball-shadow-docked: 0 4px 12px rgba(0, 0, 0, 0.07);
            --ball-shadow-dragging: 0 10px 24px rgba(0, 0, 0, 0.12);

            /* Toast（默认：亮色主题） */
            --toast-bg: rgba(255, 255, 255, 0.92);
            --toast-border: var(--border-light);
            --toast-shadow: 0 10px 30px rgba(0, 0, 0, 0.10);

            /* 弹窗（默认：亮色主题） */
            --modal-overlay-bg: rgba(10, 10, 10, 0.18);
            --modal-shadow: 0 18px 55px rgba(0, 0, 0, 0.12);
            --modal-link-underline: rgba(94, 112, 135, 0.55);
            --modal-muted: rgba(51, 51, 51, 0.70);
        }

        /* 暗黑模式：通过覆写现有主题变量适配 */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #0f1115;
                --bg-card: #161a22;
                --bg-block: #12161d;

                --text-main: #e8e8e8;
                --text-sub: rgba(232, 232, 232, 0.70);
                --text-accent: #9bb3cc;

                --border-light: rgba(255, 255, 255, 0.10);

                /* 代码/高亮 token（暗黑主题） */
                --code-bg: var(--bg-block);
                --code-border: rgba(255, 255, 255, 0.14);
                --code-demicode: #7fd0ff;
                --code-orange: #f3b06b;
                --code-blue: #8fd4ff;
                --code-purple: #d2a0ff;

                /* 悬浮条/小球（暗黑主题） */
                --bar-bg: rgba(22, 26, 34, 0.85);
                --bar-shadow: 0 10px 28px rgba(0, 0, 0, 0.55);
                --bar-border: rgba(255, 255, 255, 0.10);
                --bar-progress-strength: 22%;
                --bar-progress-fallback-alpha: 0.16;

                --ball-bg: rgba(22, 26, 34, 0.78);
                --ball-border: rgba(255, 255, 255, 0.10);
                --ball-shadow: 0 10px 26px rgba(0, 0, 0, 0.38);
                --ball-shadow-docked: 0 8px 20px rgba(0, 0, 0, 0.34);
                --ball-shadow-dragging: 0 14px 34px rgba(0, 0, 0, 0.45);

                /* Toast（暗黑主题） */
                --toast-bg: rgba(22, 26, 34, 0.92);
                --toast-border: rgba(255, 255, 255, 0.10);
                --toast-shadow: 0 12px 30px rgba(0, 0, 0, 0.55);

                /* 弹窗（暗黑主题） */
                --modal-overlay-bg: rgba(0, 0, 0, 0.52);
                --modal-shadow: 0 18px 55px rgba(0, 0, 0, 0.55);
                --modal-link-underline: rgba(155, 179, 204, 0.55);
                --modal-muted: rgba(232, 232, 232, 0.72);
            }
        }

        /* 手动主题切换：仅在用户选择后覆盖系统自动识别（默认不启用） */
        :root[data-theme="dark"] {
            color-scheme: dark;

            --bg-body: #0f1115;
            --bg-card: #161a22;
            --bg-block: #12161d;

            --text-main: #e8e8e8;
            --text-sub: rgba(232, 232, 232, 0.70);
            --text-accent: #9bb3cc;

            --border-light: rgba(255, 255, 255, 0.10);

            --code-bg: var(--bg-block);
            --code-border: rgba(255, 255, 255, 0.14);
            --code-demicode: #7fd0ff;
            --code-orange: #f3b06b;
            --code-blue: #8fd4ff;
            --code-purple: #d2a0ff;

            --bar-bg: rgba(22, 26, 34, 0.85);
            --bar-shadow: 0 10px 28px rgba(0, 0, 0, 0.55);
            --bar-border: rgba(255, 255, 255, 0.10);
            --bar-progress-strength: 22%;
            --bar-progress-fallback-alpha: 0.16;

            --ball-bg: rgba(22, 26, 34, 0.78);
            --ball-border: rgba(255, 255, 255, 0.10);
            --ball-shadow: 0 10px 26px rgba(0, 0, 0, 0.38);
            --ball-shadow-docked: 0 8px 20px rgba(0, 0, 0, 0.34);
            --ball-shadow-dragging: 0 14px 34px rgba(0, 0, 0, 0.45);

            --toast-bg: rgba(22, 26, 34, 0.92);
            --toast-border: rgba(255, 255, 255, 0.10);
            --toast-shadow: 0 12px 30px rgba(0, 0, 0, 0.55);

            --modal-overlay-bg: rgba(0, 0, 0, 0.52);
            --modal-shadow: 0 18px 55px rgba(0, 0, 0, 0.55);
            --modal-link-underline: rgba(155, 179, 204, 0.55);
            --modal-muted: rgba(232, 232, 232, 0.72);
        }

        :root[data-theme="light"] {
            color-scheme: light;

            --bg-body: #f9f8f6;
            --bg-card: #ffffff;
            --bg-block: #f4f4f2;

            --text-main: #333333;
            --text-sub: #888888;
            --text-accent: #5e7087;

            --border-light: #f0f0f0;

            --code-bg: #ffffff;
            --code-border: #e0e0e0;
            --code-demicode: #15658f;
            --code-orange: rgb(151, 80, 13);
            --code-blue: rgb(8, 56, 93);
            --code-purple: rgb(112, 31, 146);

            --bar-bg: rgba(255, 255, 255, 0.85);
            --bar-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            --bar-border: transparent;
            --bar-progress-strength: 16%;
            --bar-progress-fallback-alpha: 0.10;

            --ball-bg: rgba(255, 255, 255, 0.78);
            --ball-border: rgba(0, 0, 0, 0.06);
            --ball-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
            --ball-shadow-docked: 0 4px 12px rgba(0, 0, 0, 0.07);
            --ball-shadow-dragging: 0 10px 24px rgba(0, 0, 0, 0.12);

            --toast-bg: rgba(255, 255, 255, 0.92);
            --toast-border: var(--border-light);
            --toast-shadow: 0 10px 30px rgba(0, 0, 0, 0.10);

            --modal-overlay-bg: rgba(10, 10, 10, 0.18);
            --modal-shadow: 0 18px 55px rgba(0, 0, 0, 0.12);
            --modal-link-underline: rgba(94, 112, 135, 0.55);
            --modal-muted: rgba(51, 51, 51, 0.70);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* HTML 根元素使用变量，rem 单位将基于此缩放 */
        html {
            font-size: var(--base-font-size);
            /* 平滑过渡效果 */
            transition: font-size 0.2s ease;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg-body);
            color: var(--text-main);
            line-height: 1.75;
            padding: 50px 20px;
            font-size: 1rem;
        }

        .container {
            max-width: 700px;
            margin: 0 auto;
        }

        /* 头部设计 */
        header {
            text-align: center;
            margin-bottom: 70px;
        }

        h1 {
            font-family: var(--font-serif);
            font-size: 2rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 12px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-family: var(--font-serif);
            font-size: 0.95rem;
            color: var(--text-sub);
            letter-spacing: 1px;
        }

        /* 卡片风格 */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius);
            padding: var(--spacing);
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.025);

            transition: transform 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.04);
        }

        /* 卡片头部 */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom-style: solid;
            border-bottom-width: 1px;
            border-bottom-color: var(--border-light);
            cursor: pointer;
            transition: margin-bottom 0.28s cubic-bezier(0.2, 0.8, 0.2, 1),
                padding-bottom 0.28s cubic-bezier(0.2, 0.8, 0.2, 1),
                border-bottom-width 0.28s cubic-bezier(0.2, 0.8, 0.2, 1),
                border-bottom-color 0.22s ease;
        }

        /* 卡片折叠时：去掉标题下方的留白与分割线 */
        .card.is-collapsed .card-header {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom-width: 0;
            border-bottom-color: transparent;
        }

        .header-right {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .question {
            font-family: var(--font-serif);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-main);
            flex: 1;
            margin-right: 15px;
            line-height: 1.4;
            position: relative;
            /* 用 em 适配字号变化，避免文字贴近小三角 */
            padding-left: 1.35em;
            cursor: pointer;
            user-select: none;
        }

        .question::before {
            content: "▾";
            position: absolute;
            left: 0;
            /* 让图标随行高更居中一些 */
            top: 0.06em;
            color: var(--text-sub);
            font-family: var(--font-sans);
            transform-origin: 50% 45%;
            transition: transform 0.18s ease;
        }

        .card.is-collapsed .question::before {
            transform: rotate(-90deg);
        }

        .meta-tag {
            font-size: 0.75rem;
            color: var(--text-sub);
            font-family: var(--font-sans);
            background: transparent;
            border: 1px solid var(--border-light);
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
            letter-spacing: 0.5px;
            cursor: default;
        }

        .toggle-tag {
            cursor: pointer;
            user-select: none;
        }

        .toggle-tag:active {
            transform: scale(0.98);
        }

        /* 折叠动画容器 */
        .card-body,
        .concept-body {
            overflow: hidden;
            opacity: 1;
            transition: max-height 0.28s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.22s ease;
            will-change: max-height, opacity;
        }

        .card.is-collapsed .card-body {
            opacity: 0;
        }

        .concept-block.is-collapsed .concept-body {
            opacity: 0;
        }

        /* 列表样式 */
        ol.unified-list {
            list-style: none;
            counter-reset: item;
        }

        ol.unified-list>li {
            position: relative;
            padding-left: 28px;
            margin-bottom: 10px;
            color: var(--text-main);
        }

        ol.unified-list>li::before {
            content: counter(item) ".";
            counter-increment: item;
            position: absolute;
            left: 0;
            top: 0;
            width: 20px;
            color: var(--text-sub);
            font-family: var(--font-serif);
            font-size: 0.95rem;
            text-align: right;
            padding-right: 8px;
            font-weight: normal;
        }

        strong {
            color: var(--text-main);
            font-weight: 600;
        }

        /* 小节标题 */
        .sub-title {
            font-family: var(--font-sans);
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-accent);
            margin-top: 15px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            letter-spacing: 0.5px;
        }

        .sub-title::after {
            content: "";
            flex: 1;
            height: 1px;
            background: var(--border-light);
            margin-left: 10px;
        }

        /* 概念块 */
        .concept-block {
            background-color: var(--bg-block);
            padding: 20px;
            border-radius: 4px;
            margin: 15px 0;
            font-size: 0.95rem;
            border-left: 3px solid var(--border-light);
        }

        .concept-name {
            display: block;
            font-family: var(--font-serif);
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 10px;
            transition: margin-bottom 0.28s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .concept-name {
            position: relative;
            /* 用 em 适配字号变化，避免文字贴近小三角 */
            padding-left: 1.35em;
            cursor: pointer;
            user-select: none;
        }

        .concept-name::before {
            content: "▾";
            position: absolute;
            left: 0;
            top: 0.06em;
            color: var(--text-sub);
            font-family: var(--font-sans);
            transform-origin: 50% 45%;
            transition: transform 0.18s ease;
        }

        .concept-block.is-collapsed .concept-name::before {
            transform: rotate(-90deg);
        }

        /* 概念块折叠时：撤销标题下方的额外空间（并带动画） */
        .concept-block.is-collapsed .concept-name {
            margin-bottom: 0;
        }

        /* 代码块样式 */
        code {
            font-family: "Menlo", "Consolas", monospace;
            background: var(--code-bg);
            border: 1px solid var(--code-border);
            color: var(--text-main);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow-x: auto;
            display: inline-block;
            max-width: 100%;
        }

        demicode {
            font-family: "Menlo", "Consolas", monospace;
            background: var(--code-bg);
            color: var(--code-demicode);
            font-size: 0.9rem;
        }

        orange {
            color: var(--code-orange);
        }

        blue {
            color: var(--code-blue);
        }

        purple {
            color: var(--code-purple);
        }

        /* 页脚 */
        footer {
            text-align: center;
            margin-top: 80px;
            color: var(--text-sub);
            font-size: 0.8rem;
            font-family: var(--font-serif);
            padding-bottom: 60px;
            /* 增加底部留白，防止被悬浮按钮遮挡 */
        }

        .footer-actions {
            margin-top: 12px;
        }

        .footer-btn {
            appearance: none;
            border: 0;
            background: transparent;
            color: var(--text-sub);
            font-family: var(--font-serif);
            font-size: 0.9rem;
            padding: 2px 2px;
            border-radius: 6px;
            cursor: pointer;
            letter-spacing: 0.3px;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
            transition: all 0.18s ease;
        }

        /* .footer-btn:hover {
            color: var(--text-accent);
            background: rgba(94, 112, 135, 0.08);
            text-decoration-style: solid;
        } */

        /* 仅在支持 hover 的设备上启用 hover，避免手机点击后一直hover */
        @media (hover: hover) and (pointer: fine) {
            .footer-btn:hover {
                color: var(--text-accent);
                background: rgba(94, 112, 135, 0.08);
                text-decoration-style: solid;
            }
        }


        /* 页脚补充说明 */
        .footer-note {
            margin-top: 10px;
            color: var(--text-sub);
            font-size: 0.9rem;
            font-family: var(--font-serif);
            line-height: 1.65;
            letter-spacing: 0.3px;
        }

        .footer-actions {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Toast */
        .toast {
            position: fixed;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%) translateY(10px);
            background: var(--toast-bg);
            color: var(--text-main);
            text-align: center;
            border: 1px solid var(--toast-border);
            box-shadow: var(--toast-shadow);
            border-radius: 999px;
            padding: 10px 14px;
            font-family: var(--font-sans);
            font-size: 0.9rem;
            line-height: 1.35;
            letter-spacing: 0.2px;
            max-width: min(520px, calc(100vw - 40px));
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.18s ease, transform 0.22s ease;
            z-index: 120;
        }

        .toast.is-show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        @media (max-width: 600px) {
            .toast {
                bottom: 20px;
                font-size: 0.88rem;
                padding: 10px 12px;
            }
        }

        /* 弹窗 */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: var(--modal-overlay-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.22s ease, visibility 0s linear 0.22s;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }

        .modal-overlay.is-open {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.22s ease, visibility 0s linear 0s;
        }

        .modal {
            width: min(520px, 100%);
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border-light);
            box-shadow: var(--modal-shadow);
            overflow: hidden;
            transform: translateY(10px) scale(0.985);
            opacity: 0;
            transition: transform 0.26s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.22s ease;
        }

        .modal-overlay.is-open .modal {
            transform: translateY(0) scale(1);
            opacity: 1;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-light);
        }

        .modal-title {
            font-family: var(--font-serif);
            font-size: 1.05rem;
            color: var(--text-main);
        }

        .modal-close {
            appearance: none;
            border: 0;
            background: transparent;
            color: var(--text-sub);
            font-size: 18px;
            line-height: 1;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 8px;
        }

        .modal-body {
            padding: 16px;
            color: var(--text-main);
            font-family: var(--font-sans);
            font-size: 0.95rem;
            line-height: 1.75;
        }

        .modal-body a {
            color: var(--text-accent);
            text-decoration: none;
            border-bottom: 1px dashed var(--modal-link-underline);
        }

        .modal-muted {
            color: var(--modal-muted);
        }

        .modal-emoji {
            font-size: 1.2rem;
        }

        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        /* 悬浮栏 */
        .control-bar {
            position: fixed;
            bottom: 30px;
            right: 30px;
            /* 背景即阅读进度条：用“底色 + 叠加层宽度”避免渐变 stop 偏移/跳段 */
            background-color: var(--bar-bg);

            /* fallback：不支持 color-mix 时使用固定 alpha（仅用于强调色叠加层） */
            background-image: linear-gradient(90deg,
                    rgb(94 112 135 / var(--bar-progress-fallback-alpha)),
                    rgb(94 112 135 / var(--bar-progress-fallback-alpha)));
            /* 优先：支持 color-mix 时使用变量色（更浅一些） */
            background-image: linear-gradient(90deg,
                    color-mix(in srgb, var(--text-accent) var(--bar-progress-strength), transparent),
                    color-mix(in srgb, var(--text-accent) var(--bar-progress-strength), transparent));

            /* 进度条宽度由 --read-progress 控制 */
            background-repeat: no-repeat;
            background-size: var(--read-progress) 100%;
            background-position: left center;

            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 6px;
            border-radius: 30px;
            box-shadow: var(--bar-shadow);

            /* 用 outline 做边框：不改变布局，暗黑主题更清晰 */
            outline: 1px solid var(--bar-border);
            outline-offset: -1px;

            display: flex;
            gap: 4px;
            z-index: 100;
            transition: opacity 0.3s ease, transform 0.3s ease;
            -webkit-user-select: none;
            user-select: none;
        }

        /* 闲置时稍微降低不透明度（仅在支持 hover 的设备上启用） */
        @media (hover: hover) and (pointer: fine) {
            .control-bar:not(:hover) {
                opacity: 0.7;
                transform: scale(0.95);
            }
        }

        /* 悬浮条隐藏态 */
        .control-bar.is-hidden {
            opacity: 0;
            transform: translateY(12px) scale(0.96);
            pointer-events: none;
        }

        .control-btn {
            appearance: none;
            border: none;
            background: transparent;
            color: var(--text-sub);
            font-family: var(--font-sans);
            font-size: 14px;
            font-weight: 600;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, color 0.2s;
            -webkit-user-select: none;
            user-select: none;
        }

        /* “球”按钮：仅移动端显示（桌面端不应出现） */
        #toggleFloatBall {
            display: none;
        }

        /* 仅在支持 hover 的设备上启用 hover，避免移动端点击后残留 hover */
        @media (hover: hover) and (pointer: fine) {
            .control-btn:hover {
                background-color: var(--text-accent);
                color: #fff;
            }
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .font-display {
            font-size: 13px;
            color: var(--text-sub);
            display: flex;
            align-items: center;
            padding: 0 4px;
            font-variant-numeric: tabular-nums;
            cursor: default;
            user-select: none;
        }

        /* 移动端悬浮球（默认隐藏，仅移动端显示） */
        .float-ball {
            display: none;
            position: fixed;
            left: 14px;
            top: 60vh;
            width: 36px;
            height: 36px;
            border-radius: 999px;
            padding: 0;
            border: 1px solid var(--ball-border);

            background-color: var(--ball-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);

            box-shadow: var(--ball-shadow);
            color: var(--text-accent);

            align-items: center;
            justify-content: center;
            z-index: 110;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;

            transition:
                left 0.22s cubic-bezier(0.2, 0.8, 0.2, 1),
                top 0.22s cubic-bezier(0.2, 0.8, 0.2, 1),
                width 0.18s ease,
                height 0.18s ease,
                opacity 0.18s ease,
                transform 0.18s ease,
                box-shadow 0.18s ease;
            will-change: left, top, transform;
        }

        /* 禁用时彻底隐藏（避免移动端 display:flex 覆盖 hidden 默认样式） */
        .float-ball[hidden] {
            display: none !important;
        }

        .float-ball:active {
            transform: scale(0.96);
        }

        .float-ball__icon {
            width: 14px;
            height: 10px;
            position: relative;
            opacity: 0.72;
        }

        .float-ball__icon::before,
        .float-ball__icon::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: currentColor;
            border-radius: 999px;
            top: 50%;
            transform-origin: 50% 50%;
            transition: transform 0.22s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .float-ball__icon::before {
            transform: translateY(-4px);
        }

        .float-ball__icon::after {
            transform: translateY(4px);
        }

        /* 底栏显示：双横线旋转成叉 */
        .float-ball.is-open .float-ball__icon {
            opacity: 0.82;
        }

        .float-ball.is-open .float-ball__icon::before {
            transform: translateY(0) rotate(45deg);
        }

        .float-ball.is-open .float-ball__icon::after {
            transform: translateY(0) rotate(-45deg);
        }

        .float-ball.is-docked {
            width: 30px;
            height: 30px;
            opacity: 0.76;
            box-shadow: var(--ball-shadow-docked);
        }

        .float-ball.is-dragging {
            transition: none !important;
            opacity: 0.92;
            box-shadow: var(--ball-shadow-dragging);
        }

        /* 底栏隐藏时，失焦/闲置淡化 */
        .float-ball.is-idle {
            opacity: 0.58;
        }

        @media (prefers-reduced-motion: reduce) {
            .float-ball {
                transition: none !important;
            }

            .float-ball__icon::before,
            .float-ball__icon::after {
                transition: none !important;
            }
        }

        @media (max-width: 600px) {

            /* 移动端：取消 card hover 动效（避免点按后残留 hover） */
            .card:hover {
                transform: none;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.025);
            }

            .card-header {
                flex-direction: column-reverse;
                gap: 8px;
            }

            .header-right {
                align-self: flex-start;
            }

            .meta-tag {
                align-self: flex-start;
                border: none;
                padding-left: 0;
            }

            .question {
                font-size: 1.15rem;
            }

            /* 移动端调整悬浮按钮位置 */
            .control-bar {
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                padding: 12px 14px calc(12px + env(safe-area-inset-bottom));
                gap: 8px;
                border-radius: 16px 16px 0 0;
                opacity: 1;
                transform: none;
                justify-content: center;

                /* 显隐动画（收缩为进度条） */
                overflow: hidden;
                --ve-bar-max-h: 120px;
                max-height: var(--ve-bar-max-h);
                transition:
                    max-height 0.26s cubic-bezier(0.2, 0.8, 0.2, 1),
                    padding 0.22s ease,
                    padding-left 0.22s ease,
                    padding-right 0.22s ease,
                    border-radius 0.22s ease,
                    box-shadow 0.22s ease;
            }

            /* 需求变更：底栏显示时，小球停靠在底栏上方（不在底栏内），不再需要“挤开按钮”效果 */

            .control-bar>* {
                transition: opacity 0.18s ease;
            }

            /* 移动端隐藏态：底栏不消失，收缩为阅读进度条 */
            .control-bar.is-hidden {
                opacity: 1;
                transform: none;
                /* 隐藏态不可交互（不支持拖动调节进度） */
                pointer-events: none;
                padding: 0;
                height: 6px;
                max-height: 6px;
                border-radius: 0;
                box-shadow: none;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;

                /* 浅色模式下隐藏态进度条更显眼（仅影响该元素范围内的渐变叠加强度） */
                --bar-progress-strength: 22%;
                --bar-progress-fallback-alpha: 0.14;
            }

            .control-bar.is-hidden>* {
                opacity: 0;
            }

            /* 移动端：让悬浮条更大更易点 */
            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 15px;
            }

            /* 移动端：显示“球”按钮 */
            #toggleFloatBall {
                display: flex;
            }

            .font-display {
                font-size: 14px;
                padding: 0 6px;
            }

            .float-ball {
                display: flex;
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <!-- CONTENT -->
        <footer>
            <div class="footer-note">
                我想看看不同地区、不同网络环境下的访问响应情况，如果你愿意，可以点击
                <button class="footer-btn" id="sendGeolocation" type="button">发送定位</button>
                支持我。
            </div>
            <div class="footer-actions">
                <button class="footer-btn" id="openAuthorModal" type="button">关于作者</button>
            </div>
        </footer>
    </div>

    <!-- 控制悬浮栏 -->
    <div class="control-bar">
        <button class="control-btn" id="collapseAll" title="全部收起" type="button" aria-label="全部收起">收</button>
        <button class="control-btn" id="expandAll" title="全部展开" type="button" aria-label="全部展开">展</button>
        <button class="control-btn" id="fontDecrease" title="减小字号">A-</button>
        <span class="font-display" id="fontDisplay">15</span>
        <button class="control-btn" id="fontIncrease" title="增大字号">A+</button>
        <button class="control-btn" id="toggleTheme" title="切换深浅色" type="button" aria-label="切换深浅色"
            aria-pressed="false">自</button>
        <button class="control-btn" id="toggleFloatBall" title="启用/禁用小球" type="button" aria-label="启用或禁用小球"
            aria-pressed="true">球</button>
    </div>

    <!-- 移动端悬浮球：拖拽移动；点击显隐底栏 -->
    <button class="float-ball" id="veFloatBall" type="button" aria-label="显示或隐藏底栏">
        <span class="float-ball__icon" aria-hidden="true"></span>
    </button>

    <!-- Toast -->
    <div class="toast" id="toast" role="status" aria-live="polite" aria-atomic="true"></div>

    <!-- 作者弹窗 -->
    <div class="modal-overlay" id="authorModalOverlay" role="dialog" aria-modal="true"
        aria-labelledby="authorModalTitle">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="authorModalTitle">关于作者</div>
                <button class="modal-close" id="closeAuthorModal" type="button" aria-label="关闭弹窗">×</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom:10px;">
                    邮箱：<a href="mailto:z@qimo.uno">z@qimo.uno</a>
                </div>
                <div class="modal-muted">
                    这个邮箱是真的噢，欢迎反馈与讨论，虽然还是微信来得简单高效 <span class="modal-emoji">😉</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* 弹窗逻辑 */
        const openBtn = document.getElementById("openAuthorModal");
        const overlay = document.getElementById("authorModalOverlay");
        const closeBtn = document.getElementById("closeAuthorModal");
        const geoBtn = document.getElementById("sendGeolocation");
        const isOpen = () => overlay.classList.contains("is-open");
        let __scrollY = 0;

        const lockScroll = () => {
            __scrollY = window.scrollY || document.documentElement.scrollTop || 0;
            document.body.classList.add("modal-open");
            document.body.style.top = `-${__scrollY}px`;
        };

        const unlockScroll = () => {
            document.body.classList.remove("modal-open");
            document.body.style.top = "";
            window.scrollTo(0, __scrollY);
        };

        const openModal = () => {
            lockScroll();
            overlay.classList.add("is-open");
            window.setTimeout(() => closeBtn.focus(), 0);
        };

        const closeModal = () => {
            overlay.classList.remove("is-open");
            unlockScroll();
            window.setTimeout(() => openBtn.focus(), 0);
        };

        openBtn.addEventListener("click", openModal);
        closeBtn.addEventListener("click", closeModal);
        overlay.addEventListener("click", (e) => {
            if (e.target === overlay) closeModal();
        });
        // 弹窗打开时：阻止“滚动穿透”，但允许缩放
        // - 触摸板双指缩放（通常表现为 ctrlKey + wheel）需要放行
        // - 手机/触摸屏双指捏合（2+ touches）需要放行
        overlay.addEventListener("wheel", (e) => {
            if (!isOpen()) return;
            if (e && e.ctrlKey) return;
            e.preventDefault();
        }, { passive: false });
        overlay.addEventListener("touchmove", (e) => {
            if (!isOpen()) return;
            if (e && e.touches && e.touches.length >= 2) return;
            e.preventDefault();
        }, { passive: false });
        window.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && isOpen()) closeModal();
        });

        /* 移动端：底栏显隐交互（默认显示；点击空白区切换；仅用户在底栏外滑动才隐藏） */
        (function () {
            const bar = document.querySelector('.control-bar');
            if (!bar) return;

            const mq = window.matchMedia('(max-width: 600px)');
            if (!mq.matches) return;

            let hidden = false;
            const setHidden = (next) => {
                const shouldHide = Boolean(next);
                if (shouldHide === hidden) return;
                hidden = shouldHide;
                bar.classList.toggle('is-hidden', hidden);
                bar.setAttribute('aria-hidden', hidden ? 'true' : 'false');

                // 通知外部（悬浮球）底栏状态变化
                try {
                    window.dispatchEvent(new CustomEvent('ve:mobilebar', { detail: { hidden } }));
                } catch (_) {
                    // ignore
                }
            };

            const hideBar = () => setHidden(true);
            const showBar = () => setHidden(false);
            const toggleBar = () => setHidden(!hidden);

            // 点击“空白区”切换显示/隐藏（不影响功能区点击）
            document.addEventListener('click', (e) => {
                if (!mq.matches) return;
                if (typeof isOpen === 'function' && isOpen()) return;

                const target = e.target;
                const inBall = target && target.closest && target.closest('.float-ball');
                if (inBall) return;

                const inBar = target && target.closest && target.closest('.control-bar');
                if (inBar) return;

                if (target && target.closest) {
                    // 弹窗区域：不切换
                    if (target.closest('.modal-overlay, .modal')) return;

                    const isInteractive = Boolean(target.closest('button, a, input, textarea, select'));
                    const isFunctionalZone = Boolean(target.closest('.card-header, .question, .concept-name, .meta-tag'));

                    // 点击功能区/交互区：只允许隐藏，不允许显示
                    if (isInteractive || isFunctionalZone) {
                        if (!hidden) hideBar();
                        return;
                    }
                }

                toggleBar();
            }, true);

            // 仅当用户“手势滑动”且起点在底栏外时才隐藏（避免程序性滚动影响）
            let startY = null;
            let startInBar = false;
            let gestureTriggered = false;
            const THRESHOLD = 24;

            document.addEventListener('touchstart', (e) => {
                if (!mq.matches) return;
                if (typeof isOpen === 'function' && isOpen()) return;
                if (!e.touches || e.touches.length !== 1) return;

                const t = e.touches[0];
                startY = t.clientY;
                gestureTriggered = false;
                // 在底栏或悬浮球上起手：不触发“外部滑动隐藏底栏”规则
                startInBar = Boolean(e.target && e.target.closest && e.target.closest('.control-bar, .float-ball'));
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!mq.matches) return;
                if (typeof isOpen === 'function' && isOpen()) return;
                if (gestureTriggered) return;
                if (startY == null) return;
                if (!e.touches || e.touches.length !== 1) return;
                if (startInBar) return;
                if (hidden) return;

                const currentY = e.touches[0].clientY;
                const delta = currentY - startY;
                if (Math.abs(delta) < THRESHOLD) return;

                gestureTriggered = true;
                hideBar();
            }, { passive: true });

            document.addEventListener('touchend', () => {
                startY = null;
                startInBar = false;
                gestureTriggered = false;
            }, { passive: true });

            // 默认显示
            showBar();

            /* 移动端：长按底栏并左右拖动，调节阅读进度 */
            (function setupBarScrub() {
                const HOLD_MS = 240;
                // 仅在“明显纵向滑动（更像滚动）”时才取消长按进入 scrub
                const V_CANCEL_PX = 14;

                let pressTimer = null;
                let activePointerId = null;
                let scrubbing = false;
                let suppressClick = false;
                let startX = 0;
                let startY = 0;
                let lastX = 0;
                let lastY = 0;
                let movedTooMuch = false;

                const clearPressTimer = () => {
                    if (pressTimer) window.clearTimeout(pressTimer);
                    pressTimer = null;
                };

                const clamp01 = (n) => Math.min(1, Math.max(0, n));

                // 需求：在 .control-btn / #fontDisplay 上长按也要触发拖动

                const scrollToProgress = (clientX) => {
                    const rect = bar.getBoundingClientRect();
                    if (!rect || rect.width <= 1) return;
                    const x = clientX - rect.left;
                    const p = clamp01(x / rect.width);

                    const docEl = document.documentElement;
                    const clientH = window.innerHeight || docEl.clientHeight || 0;
                    const denom = Math.max(1, (docEl.scrollHeight || 0) - clientH);
                    const y = Math.round(p * denom);
                    window.scrollTo(0, y);

                    if (typeof window.__veUpdateReadProgress === 'function') {
                        window.__veUpdateReadProgress();
                    }
                };

                const onPointerDown = (e) => {
                    if (!mq.matches) return;
                    if (typeof isOpen === 'function' && isOpen()) return;
                    // 隐藏态不可用
                    if (bar.classList.contains('is-hidden')) return;
                    if (!e || e.pointerId == null) return;
                    if (activePointerId != null) return;

                    activePointerId = e.pointerId;
                    scrubbing = false;
                    movedTooMuch = false;
                    startX = e.clientX;
                    startY = e.clientY;
                    lastX = e.clientX;
                    lastY = e.clientY;

                    clearPressTimer();
                    pressTimer = window.setTimeout(() => {
                        // 如果用户在长按期间明显滑动了，就不进入 scrub（避免影响正常滚动）
                        if (movedTooMuch) return;
                        scrubbing = true;
                        suppressClick = true;
                        try {
                            bar.setPointerCapture(activePointerId);
                        } catch (_) { }
                        // 进入 scrub 的第一下也立即对齐
                        scrollToProgress(lastX);
                    }, HOLD_MS);
                };

                const onPointerMove = (e) => {
                    if (activePointerId == null) return;
                    if (e.pointerId !== activePointerId) return;

                    lastX = e.clientX;
                    lastY = e.clientY;

                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;

                    // 还没进入 scrub：允许小范围移动；只有明显“纵向为主”的滑动才取消
                    if (!scrubbing && !movedTooMuch) {
                        const absDx = Math.abs(dx);
                        const absDy = Math.abs(dy);
                        const verticalDominant = absDy > absDx * 1.25;
                        if (verticalDominant && absDy > V_CANCEL_PX) {
                            movedTooMuch = true;
                            clearPressTimer();
                        }
                    }

                    if (!scrubbing) return;
                    // scrub 模式下：阻止页面滚动手势
                    e.preventDefault();
                    scrollToProgress(e.clientX);
                };

                const endScrub = () => {
                    clearPressTimer();
                    activePointerId = null;
                    scrubbing = false;
                    movedTooMuch = false;
                };

                const onPointerUp = (e) => {
                    if (activePointerId == null) return;
                    if (e.pointerId !== activePointerId) return;
                    if (scrubbing) e.preventDefault();
                    endScrub();
                };

                const onPointerCancel = (e) => {
                    if (activePointerId == null) return;
                    if (e.pointerId !== activePointerId) return;
                    endScrub();
                };

                bar.addEventListener('pointerdown', onPointerDown, { passive: true });
                bar.addEventListener('pointermove', onPointerMove, { passive: false });
                bar.addEventListener('pointerup', onPointerUp, { passive: false });
                bar.addEventListener('pointercancel', onPointerCancel, { passive: true });

                // scrub 触发后，抑制一次 click，避免长按松手误点到底栏按钮
                bar.addEventListener('click', (e) => {
                    if (!suppressClick) return;
                    suppressClick = false;
                    e.preventDefault();
                    e.stopPropagation();
                    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
                }, true);
            })();

            // 暴露给悬浮球调用
            window.__veMobileBar = {
                show: showBar,
                hide: hideBar,
                toggle: toggleBar,
                isHidden: () => hidden,
                el: bar
            };
        })();

        /* 移动端悬浮球：拖拽 + 左右吸附 + Q弹拉伸；点击显隐底栏（方案 D） */
        (function () {
            const ball = document.getElementById('veFloatBall');
            if (!ball) return;

            const mq = window.matchMedia('(max-width: 600px)');
            if (!mq.matches) return;

            const prefersReduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const STORAGE_KEY = 've10_float_ball_v1';
            const ENABLE_KEY = 've10_float_ball_enabled_v1';

            const EDGE = 12;
            const DOCK_EDGE = 14;
            const SIZE = 36;
            const DOCK_SIZE = 30;
            const CLICK_DRAG_THRESHOLD = 8;

            const IDLE_DELAY_MS = 900;

            const toggleBtn = document.getElementById('toggleFloatBall');

            const readEnabled = () => {
                try {
                    const raw = localStorage.getItem(ENABLE_KEY);
                    if (raw == null) return true;
                    return raw === '1';
                } catch (_) {
                    return true;
                }
            };

            const writeEnabled = (v) => {
                try {
                    localStorage.setItem(ENABLE_KEY, v ? '1' : '0');
                } catch (_) {
                    // ignore
                }
            };

            let enabled = readEnabled();

            const applyEnabledToUI = () => {
                ball.hidden = !enabled;
                ball.setAttribute('aria-hidden', enabled ? 'false' : 'true');
                if (toggleBtn) {
                    toggleBtn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                }
            };

            const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

            const readSaved = () => {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (!raw) return null;
                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== 'object') return null;
                    return parsed;
                } catch (_) {
                    return null;
                }
            };

            const writeSaved = (data) => {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                } catch (_) {
                    // ignore
                }
            };

            const getBallSize = () => (ball.classList.contains('is-docked') ? DOCK_SIZE : SIZE);

            const setPos = (x, y, animate = true) => {
                if (!animate || prefersReduceMotion) {
                    ball.classList.add('is-dragging');
                    ball.style.left = Math.round(x) + 'px';
                    ball.style.top = Math.round(y) + 'px';
                    // 让浏览器有一帧应用后再恢复
                    window.requestAnimationFrame(() => ball.classList.remove('is-dragging'));
                    return;
                }
                ball.style.left = Math.round(x) + 'px';
                ball.style.top = Math.round(y) + 'px';
            };

            const getViewportBounds = (size) => {
                const w = window.innerWidth || document.documentElement.clientWidth || 0;
                const h = window.innerHeight || document.documentElement.clientHeight || 0;
                return {
                    minX: EDGE,
                    maxX: Math.max(EDGE, w - EDGE - size),
                    minY: EDGE,
                    maxY: Math.max(EDGE, h - EDGE - size),
                    w,
                    h
                };
            };

            // 记录“浮动态位置”（底栏隐藏时使用）与“吸附侧”
            let state = readSaved() || {
                side: 'right',
                x: null,
                y: null
            };

            const ensureInitPosition = () => {
                const size = SIZE;
                const { minX, maxX, minY, maxY, w, h } = getViewportBounds(size);

                const defaultX = w - EDGE - size;
                const defaultY = Math.round(h * 0.62);

                const x = clamp((typeof state.x === 'number' ? state.x : defaultX), minX, maxX);
                const y = clamp((typeof state.y === 'number' ? state.y : defaultY), minY, maxY);
                state.x = x;
                state.y = y;
                state.side = (state.side === 'left' || state.side === 'right') ? state.side : 'right';

                ball.classList.remove('is-docked');
                setPos(x, y, false);
                writeSaved(state);
            };

            const setTransform = (angleRad, scaleX, scaleY) => {
                if (prefersReduceMotion) return;
                const a = Number.isFinite(angleRad) ? angleRad : 0;
                const sx = Number.isFinite(scaleX) ? scaleX : 1;
                const sy = Number.isFinite(scaleY) ? scaleY : 1;
                // 旋转到速度方向拉伸，再旋回，视觉方向不变
                ball.style.transform = `translateZ(0) rotate(${a}rad) scaleX(${sx}) scaleY(${sy}) rotate(${-a}rad)`;
            };

            const resetTransform = () => {
                ball.style.transform = '';
            };

            const getBarApi = () => window.__veMobileBar;

            const setBarPush = (sideOrNull) => {
                const barApi = getBarApi();
                if (!barApi || !barApi.el) return;
                const barEl = barApi.el;
                // 需求变更：小球停靠在底栏上方（不再占用底栏内部空间），因此取消“挤开按钮”效果。
                if (barPushTimer) window.clearTimeout(barPushTimer);
                barPushTimer = null;
                barEl.classList.remove('ball-push');
                barEl.classList.remove('has-ball-left');
                barEl.classList.remove('has-ball-right');
            };

            let idleTimer = null;
            let dockAlignTimer = null;
            let dockEndHandler = null;
            let dockEndEl = null;
            let barPushTimer = null;
            let dockBarExpandedH = null;

            const clearDockAlign = () => {
                if (dockAlignTimer) window.clearTimeout(dockAlignTimer);
                dockAlignTimer = null;
                if (dockEndEl && dockEndHandler) {
                    dockEndEl.removeEventListener('transitionend', dockEndHandler);
                }
                dockEndEl = null;
                dockEndHandler = null;

                if (barPushTimer) window.clearTimeout(barPushTimer);
                barPushTimer = null;
            };
            const clearIdle = () => {
                if (idleTimer) window.clearTimeout(idleTimer);
                idleTimer = null;
                ball.classList.remove('is-idle');
            };

            const scheduleIdleIfNeeded = () => {
                const barApi = getBarApi();
                if (!barApi || typeof barApi.isHidden !== 'function') return;
                if (!barApi.isHidden()) return;
                if (dragging) return;
                if (idleTimer) window.clearTimeout(idleTimer);
                idleTimer = window.setTimeout(() => {
                    const api = getBarApi();
                    if (!api || typeof api.isHidden !== 'function') return;
                    if (!api.isHidden()) return;
                    if (dragging) return;
                    ball.classList.add('is-idle');
                }, IDLE_DELAY_MS);
            };

            const dockToBar = () => {
                const barApi = getBarApi();
                if (!barApi || !barApi.el) return;
                const barEl = barApi.el;

                // 终点计算：横向用常量，纵向用“加载时测得的展开态高度 H”。
                // 这样既能与底栏动画同时移动，又不会依赖过渡中的中间态尺寸。
                const BAR_PAD_X = 14;
                const GAP_ABOVE_BAR = 8;

                const side = (state.side === 'left') ? 'left' : 'right';
                const size = DOCK_SIZE;
                const bounds = getViewportBounds(size);

                const vw = bounds.w;
                const vh = bounds.h;
                const H = (Number.isFinite(dockBarExpandedH) && dockBarExpandedH > 0) ? dockBarExpandedH : 64;
                const barTop = vh - H;

                // 横向：贴近底栏左右内边距区域
                const xAbove = (side === 'left')
                    ? BAR_PAD_X
                    : (vw - BAR_PAD_X - size);

                // 纵向：停在底栏上沿外侧
                const yAbove = barTop - GAP_ABOVE_BAR - size;

                const x = clamp(xAbove, bounds.minX, bounds.maxX);
                const y = clamp(yAbove, bounds.minY, bounds.maxY);

                ball.classList.add('is-docked');
                ball.classList.add('is-open');
                setBarPush(null);
                clearIdle();
                setPos(x, y, true);
            };

            const measureBarExpandedHeight = () => {
                const api = getBarApi();
                if (!api || !api.el) return null;
                const barEl = api.el;

                // 关闭动画，临时切到展开态测一次真实高度
                const prevTransition = barEl.style.transition;
                const prevWillChange = barEl.style.willChange;
                const wasHidden = barEl.classList.contains('is-hidden');

                barEl.style.transition = 'none';
                barEl.style.willChange = 'auto';
                if (wasHidden) barEl.classList.remove('is-hidden');
                void barEl.offsetHeight;

                const h = barEl.getBoundingClientRect().height;

                if (wasHidden) barEl.classList.add('is-hidden');
                void barEl.offsetHeight;
                barEl.style.transition = prevTransition;
                barEl.style.willChange = prevWillChange;

                return Number.isFinite(h) && h > 0 ? h : null;
            };

            const refreshDockBarHeight = () => {
                const h = measureBarExpandedHeight();
                if (h != null) dockBarExpandedH = h;
            };

            const dockToBarStable = () => {
                const barApi = getBarApi();
                if (!barApi || !barApi.el) return;
                if (typeof barApi.isHidden === 'function' && barApi.isHidden()) return;
                const barEl = barApi.el;

                clearDockAlign();

                // 与底栏展开动画同时：下一帧立即停靠到“设计终点”
                window.requestAnimationFrame(() => {
                    if (!mq.matches) return;
                    if (!enabled) return;
                    if (dragging) return;
                    const api = getBarApi();
                    if (api && typeof api.isHidden === 'function' && api.isHidden()) return;
                    if (barEl.classList.contains('is-hidden')) return;
                    dockToBar();
                });
            };

            const undockToFloating = () => {
                clearDockAlign();
                setBarPush(null);
                const size = SIZE;
                const { minX, maxX, minY, maxY } = getViewportBounds(size);
                const x = clamp(state.x, minX, maxX);
                const y = clamp(state.y, minY, maxY);
                ball.classList.remove('is-docked');
                ball.classList.remove('is-open');
                setPos(x, y, true);
                scheduleIdleIfNeeded();
            };

            const syncWithBar = () => {
                const barApi = getBarApi();
                if (!barApi || typeof barApi.isHidden !== 'function') {
                    ensureInitPosition();
                    return;
                }

                if (!enabled) {
                    clearIdle();
                    clearDockAlign();
                    setBarPush(null);
                    return;
                }

                if (barApi.isHidden()) {
                    undockToFloating();
                } else {
                    dockToBarStable();
                }
            };

            // 初始化位置
            ensureInitPosition();
            refreshDockBarHeight();
            applyEnabledToUI();
            syncWithBar();

            // 底栏状态变化：显示则停靠，隐藏则回浮动
            window.addEventListener('ve:mobilebar', (e) => {
                if (!mq.matches) return;
                if (!enabled) return;
                // 拖拽过程中不要响应底栏状态事件，避免把小球位置/状态打断
                if (dragging) return;
                const hidden = Boolean(e && e.detail && e.detail.hidden);
                if (hidden) {
                    undockToFloating();
                } else {
                    dockToBarStable();
                }
            });

            // 屏幕变化时：重新 clamp & 重新停靠
            window.addEventListener('resize', () => {
                if (!mq.matches) return;
                refreshDockBarHeight();
                syncWithBar();
            });

            // 底栏按钮：启用/禁用小球
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    enabled = !enabled;
                    writeEnabled(enabled);
                    applyEnabledToUI();

                    if (!enabled) {
                        clearIdle();
                        clearDockAlign();
                        setBarPush(null);
                        resetTransform();
                        return;
                    }

                    syncWithBar();
                    scheduleIdleIfNeeded();
                });
            }

            // 拖拽 + Q弹形变
            let dragging = false;
            let moved = false;
            let pointerId = null;
            let startClientX = 0;
            let startClientY = 0;
            let startLeft = 0;
            let startTop = 0;

            let lastX = 0;
            let lastY = 0;
            let lastT = 0;
            let vxf = 0;
            let vyf = 0;

            const easeOut = (t) => 1 - Math.pow(1 - t, 3);

            const onPointerDown = (e) => {
                if (!mq.matches) return;
                if (!enabled) return;
                if (typeof isOpen === 'function' && isOpen()) return;
                if (!e || e.button != null && e.button !== 0) return;

                clearIdle();

                // 如果当前停靠，拖动时先切到浮动尺寸（但不改变“浮动位置”记录）
                if (ball.classList.contains('is-docked')) {
                    ball.classList.remove('is-docked');
                }

                dragging = true;
                moved = false;
                pointerId = e.pointerId;
                ball.classList.add('is-dragging');
                ball.setPointerCapture(pointerId);

                const rect = ball.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                startClientX = e.clientX;
                startClientY = e.clientY;

                lastX = e.clientX;
                lastY = e.clientY;
                lastT = performance.now();
                vxf = 0;
                vyf = 0;
            };

            const onPointerMove = (e) => {
                if (!dragging) return;
                if (pointerId !== e.pointerId) return;

                const dx = e.clientX - startClientX;
                const dy = e.clientY - startClientY;
                if (!moved && (Math.hypot(dx, dy) >= CLICK_DRAG_THRESHOLD)) {
                    moved = true;
                    // 底栏显示时：一旦确定在拖拽，就立即隐藏底栏
                    const barApi = getBarApi();
                    if (barApi && typeof barApi.isHidden === 'function' && !barApi.isHidden()) {
                        if (typeof barApi.hide === 'function') barApi.hide();
                        // 由于拖拽中会忽略 ve:mobilebar 事件，这里手动同步图标状态
                        ball.classList.remove('is-open');
                    }
                }

                const size = SIZE;
                const bounds = getViewportBounds(size);
                const nextLeft = clamp(startLeft + dx, bounds.minX, bounds.maxX);
                const nextTop = clamp(startTop + dy, bounds.minY, bounds.maxY);
                ball.style.left = Math.round(nextLeft) + 'px';
                ball.style.top = Math.round(nextTop) + 'px';

                // 速度向量 + 低通滤波，驱动拉伸方向
                const now = performance.now();
                const dt = Math.max(8, now - lastT);
                const vx = (e.clientX - lastX) / dt;
                const vy = (e.clientY - lastY) / dt;

                lastX = e.clientX;
                lastY = e.clientY;
                lastT = now;

                const FILTER = 0.25;
                vxf = vxf + (vx - vxf) * FILTER;
                vyf = vyf + (vy - vyf) * FILTER;

                const speed = Math.hypot(vxf, vyf);
                const V_MAX = 1.0; // px/ms（更敏感，略更Q弹）
                const speed01 = clamp(speed / V_MAX, 0, 1);
                const k = easeOut(speed01);

                if (speed < 0.05) {
                    setTransform(0, 1, 1);
                    return;
                }

                const angle = Math.atan2(vyf, vxf);
                // 更 Q 弹：更明显的拉伸与压扁
                const stretch = 1 + 0.26 * k;
                const squash = 1 - 0.14 * k;
                setTransform(angle, stretch, squash);
            };

            const settleTransform = () => {
                if (prefersReduceMotion) {
                    resetTransform();
                    return;
                }
                // 更 Q 弹：松手时轻微过冲再回到圆形
                ball.style.transition = '';
                ball.style.transform = 'translateZ(0) scaleX(0.94) scaleY(1.06)';
                window.requestAnimationFrame(() => {
                    window.requestAnimationFrame(() => resetTransform());
                });
            };

            const snapToSide = () => {
                const rect = ball.getBoundingClientRect();
                const size = SIZE;
                const bounds = getViewportBounds(size);
                const centerX = rect.left + rect.width / 2;

                const side = centerX < bounds.w / 2 ? 'left' : 'right';
                state.side = side;

                const x = (side === 'left') ? bounds.minX : bounds.maxX;
                const y = clamp(rect.top, bounds.minY, bounds.maxY);

                state.x = x;
                state.y = y;
                writeSaved(state);

                setPos(x, y, true);
            };

            const updateSideByCurrentPosition = () => {
                const rect = ball.getBoundingClientRect();
                const bounds = getViewportBounds(SIZE);
                const centerX = rect.left + rect.width / 2;
                const side = centerX < bounds.w / 2 ? 'left' : 'right';
                state.side = side;
                writeSaved(state);
                return side;
            };

            const onPointerUp = (e) => {
                if (!dragging) return;
                if (pointerId !== e.pointerId) return;

                dragging = false;
                pointerId = null;
                ball.classList.remove('is-dragging');

                if (!moved) {
                    // 点击：显隐底栏
                    const barApi = getBarApi();
                    if (barApi && typeof barApi.toggle === 'function') {
                        barApi.toggle();
                    }
                    settleTransform();
                    return;
                }

                settleTransform();

                const barApi = getBarApi();
                const barVisible = Boolean(barApi && typeof barApi.isHidden === 'function' && !barApi.isHidden());

                if (barVisible) {
                    // 底栏显示时：不保存浮动坐标、不做中间吸边，直接回到“底栏内部停靠位”
                    updateSideByCurrentPosition();
                    dockToBarStable();
                    return;
                }

                // 底栏隐藏时：正常吸附左右边并保存位置
                snapToSide();
                scheduleIdleIfNeeded();
            };

            const onPointerCancel = (e) => {
                if (!dragging) return;
                if (pointerId !== e.pointerId) return;
                dragging = false;
                pointerId = null;
                ball.classList.remove('is-dragging');
                settleTransform();
                syncWithBar();
            };

            // 失焦：仅在底栏隐藏时淡化
            ball.addEventListener('blur', () => {
                scheduleIdleIfNeeded();
            });

            ball.addEventListener('focus', () => {
                clearIdle();
            });

            ball.addEventListener('pointerdown', onPointerDown);
            ball.addEventListener('pointermove', onPointerMove);
            ball.addEventListener('pointerup', onPointerUp);
            ball.addEventListener('pointercancel', onPointerCancel);
        })();

        /* 折叠/展开：卡片与概念块（默认展开） */
        (function () {
            const STORAGE_KEY = 've_fold_state_v1';
            const foldState = (() => {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (!raw) return { cards: {}, concepts: {} };
                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== 'object') return { cards: {}, concepts: {} };
                    return {
                        cards: (parsed.cards && typeof parsed.cards === 'object') ? parsed.cards : {},
                        concepts: (parsed.concepts && typeof parsed.concepts === 'object') ? parsed.concepts : {}
                    };
                } catch (_) {
                    return { cards: {}, concepts: {} };
                }
            })();

            let saveTimer = null;
            const scheduleSaveFoldState = () => {
                if (saveTimer) return;
                saveTimer = window.setTimeout(() => {
                    saveTimer = null;
                    try {
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(foldState));
                    } catch (_) {
                        // ignore
                    }
                }, 60);
            };

            const normalizeTextKey = (s) => String(s || '')
                .replace(/\s+/g, ' ')
                .trim()
                .slice(0, 80);

            const ensureCardKey = (card, index, questionEl) => {
                if (!card) return null;
                const existing = card.getAttribute('data-ve-card-key');
                if (existing) return existing;
                const q = normalizeTextKey(questionEl ? questionEl.textContent : '');
                const key = `card:${index}:${q}`;
                card.setAttribute('data-ve-card-key', key);
                return key;
            };

            const ensureConceptKey = (block, index, cardKey, nameEl) => {
                if (!block) return null;
                const existing = block.getAttribute('data-ve-concept-key');
                if (existing) return existing;
                const n = normalizeTextKey(nameEl ? nameEl.textContent : '');
                const key = `concept:${cardKey || 'nocard'}:${index}:${n}`;
                block.setAttribute('data-ve-concept-key', key);
                return key;
            };

            const setBodyCollapsedInstant = (bodyEl, collapsed) => {
                if (!bodyEl) return;
                if (bodyEl.__veOnEnd) {
                    bodyEl.removeEventListener('transitionend', bodyEl.__veOnEnd);
                    bodyEl.__veOnEnd = null;
                }
                const prevTransition = bodyEl.style.transition;
                bodyEl.style.transition = 'none';
                bodyEl.style.maxHeight = collapsed ? '0px' : 'none';
                bodyEl.style.opacity = collapsed ? '0' : '1';
                void bodyEl.offsetHeight;
                bodyEl.style.transition = prevTransition;
            };

            function prepareCardBody(card) {
                if (!card || card.querySelector(':scope > .card-body')) return;

                const body = document.createElement('div');
                body.className = 'card-body';

                // 将除 card-header 与 concept-block 外的直接子元素全部移入 body
                const children = Array.from(card.children);
                children.forEach((child) => {
                    if (child.classList.contains('card-header')) return;
                    if (child.classList.contains('concept-block')) return;
                    body.appendChild(child);
                });

                const header = card.querySelector(':scope > .card-header');
                if (header && header.nextSibling) {
                    card.insertBefore(body, header.nextSibling);
                } else {
                    card.appendChild(body);
                }

                // 默认展开：不限制 max-height，避免后续字号变化裁切
                body.style.maxHeight = 'none';
                body.style.opacity = '1';
            }

            function prepareConceptBody(block) {
                if (!block || block.querySelector(':scope > .concept-body')) return;

                const nameEl = block.querySelector(':scope > .concept-name');
                const body = document.createElement('div');
                body.className = 'concept-body';

                const children = Array.from(block.children);
                children.forEach((child) => {
                    if (child === nameEl) return;
                    body.appendChild(child);
                });
                block.appendChild(body);

                body.style.maxHeight = 'none';
                body.style.opacity = '1';
            }

            function collapseBody(bodyEl) {
                if (!bodyEl) return;
                // 取消可能残留的展开结束监听（避免快速连点时状态被旧回调覆盖）
                if (bodyEl.__veOnEnd) {
                    bodyEl.removeEventListener('transitionend', bodyEl.__veOnEnd);
                    bodyEl.__veOnEnd = null;
                }

                // 从当前可见高度起步再收起，避免打断动画时高度计算异常
                const startHeight = bodyEl.getBoundingClientRect().height;
                bodyEl.style.maxHeight = startHeight + 'px';
                void bodyEl.offsetHeight;
                bodyEl.style.maxHeight = '0px';
                bodyEl.style.opacity = '0';
            }

            function expandBody(bodyEl) {
                if (!bodyEl) return;
                // 取消可能残留的旧监听（避免监听堆积/快速连点时错乱）
                if (bodyEl.__veOnEnd) {
                    bodyEl.removeEventListener('transitionend', bodyEl.__veOnEnd);
                    bodyEl.__veOnEnd = null;
                }

                bodyEl.style.opacity = '1';

                // 关键：先临时解除 max-height 限制再测量目标高度，避免连点时 scrollHeight 读到 0
                const startHeight = bodyEl.getBoundingClientRect().height;
                bodyEl.style.maxHeight = 'none';
                const targetHeight = bodyEl.scrollHeight;
                bodyEl.style.maxHeight = startHeight + 'px';
                void bodyEl.offsetHeight;
                bodyEl.style.maxHeight = targetHeight + 'px';

                // 展开动画结束后解除 max-height 限制，避免字体变大后被裁切
                const onEnd = (e) => {
                    if (e.target !== bodyEl) return;
                    if (e.propertyName !== 'max-height') return;
                    bodyEl.style.maxHeight = 'none';
                    bodyEl.removeEventListener('transitionend', onEnd);
                    bodyEl.__veOnEnd = null;
                };

                bodyEl.__veOnEnd = onEnd;
                bodyEl.addEventListener('transitionend', onEnd);
            }

            // Card：点击题目(question)折叠/展开；折叠时强制折叠该卡片内所有 concept-block
            const allCards = Array.from(document.querySelectorAll('.card'));
            allCards.forEach((card, cardIndex) => {
                const questionEl = card.querySelector('.card-header .question');
                if (!questionEl) return;

                const headerEl = card.querySelector(':scope > .card-header');

                prepareCardBody(card);
                const cardBody = card.querySelector(':scope > .card-body');

                const cardKey = ensureCardKey(card, cardIndex, questionEl);

                questionEl.setAttribute('role', 'button');
                questionEl.setAttribute('tabindex', '0');
                questionEl.setAttribute('aria-expanded', 'true');
                questionEl.title = '折叠/展开';

                const collapseConceptBlocks = () => {
                    card.querySelectorAll('.concept-block').forEach((block, conceptIndex) => {
                        prepareConceptBody(block);
                        if (!block.classList.contains('is-collapsed')) {
                            block.classList.add('is-collapsed');
                        }
                        const nameEl = block.querySelector('.concept-name');
                        if (nameEl) nameEl.setAttribute('aria-expanded', 'false');

                        const body = block.querySelector(':scope > .concept-body');
                        collapseBody(body);

                        const conceptKey = ensureConceptKey(block, conceptIndex, cardKey, nameEl);
                        if (conceptKey) {
                            foldState.concepts[conceptKey] = true;
                        }
                    });
                    scheduleSaveFoldState();
                };

                const expandConceptBlocks = () => {
                    card.querySelectorAll('.concept-block').forEach((block, conceptIndex) => {
                        prepareConceptBody(block);

                        if (block.classList.contains('is-collapsed')) {
                            block.classList.remove('is-collapsed');
                        }

                        const nameEl = block.querySelector('.concept-name');
                        if (nameEl) nameEl.setAttribute('aria-expanded', 'true');

                        const body = block.querySelector(':scope > .concept-body');
                        expandBody(body);

                        const conceptKey = ensureConceptKey(block, conceptIndex, cardKey, nameEl);
                        if (conceptKey) {
                            foldState.concepts[conceptKey] = false;
                        }
                    });
                    scheduleSaveFoldState();
                };

                const toggleCard = () => {
                    const collapsed = card.classList.toggle('is-collapsed');
                    questionEl.setAttribute('aria-expanded', collapsed ? 'false' : 'true');

                    if (cardKey) {
                        foldState.cards[cardKey] = collapsed;
                        scheduleSaveFoldState();
                    }

                    // 题目折叠：概念块全部折叠
                    if (collapsed) {
                        collapseConceptBlocks();
                        collapseBody(cardBody);
                    } else {
                        expandBody(cardBody);
                        // 展开题目时：展开其内所有概念块（并更新持久化）
                        expandConceptBlocks();
                    }

                    // 题目展开：概念块全部展开（覆盖其原持久化状态）

                    // 折叠/展开会改变页面高度，刷新阅读进度条
                    if (typeof window.__veUpdateReadProgress === 'function') {
                        window.requestAnimationFrame(() => window.__veUpdateReadProgress());
                    }
                };

                // 恢复 card 折叠状态（加载时不走动画）
                const shouldCollapseCard = Boolean(cardKey && foldState.cards[cardKey]);
                if (shouldCollapseCard) {
                    if (!card.classList.contains('is-collapsed')) card.classList.add('is-collapsed');
                    questionEl.setAttribute('aria-expanded', 'false');
                    setBodyCollapsedInstant(cardBody, true);
                } else {
                    if (card.classList.contains('is-collapsed')) card.classList.remove('is-collapsed');
                    questionEl.setAttribute('aria-expanded', 'true');
                    setBodyCollapsedInstant(cardBody, false);
                }

                // 点击标题所在行（包含空白区域）折叠/展开；点击 meta-tag 不触发
                if (headerEl) {
                    headerEl.addEventListener('click', (e) => {
                        if (e.target && e.target.closest && e.target.closest('.meta-tag')) return;
                        e.preventDefault();
                        toggleCard();
                    });
                }

                questionEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleCard();
                    }
                });
            });

            // Concept-block：点击 concept-name 折叠其内部内容
            document.querySelectorAll('.concept-block').forEach((block, conceptIndex) => {
                prepareConceptBody(block);
                const nameEl = block.querySelector('.concept-name');
                if (!nameEl) return;

                const conceptBody = block.querySelector(':scope > .concept-body');

                const parentCard = block.closest('.card');
                const parentQuestionEl = parentCard ? parentCard.querySelector('.card-header .question') : null;
                const parentCardIndex = parentCard ? allCards.indexOf(parentCard) : -1;
                const parentCardKey = parentCard ? ensureCardKey(parentCard, parentCardIndex >= 0 ? parentCardIndex : 0, parentQuestionEl) : 'nocard';
                const conceptKey = ensureConceptKey(block, conceptIndex, parentCardKey, nameEl);

                nameEl.setAttribute('role', 'button');
                nameEl.setAttribute('tabindex', '0');
                nameEl.setAttribute('aria-expanded', 'true');
                nameEl.title = '折叠/展开';

                const toggle = () => {
                    const collapsed = block.classList.toggle('is-collapsed');
                    nameEl.setAttribute('aria-expanded', collapsed ? 'false' : 'true');

                    if (collapsed) {
                        collapseBody(conceptBody);
                    } else {
                        expandBody(conceptBody);
                    }

                    if (conceptKey) {
                        foldState.concepts[conceptKey] = collapsed;
                        scheduleSaveFoldState();
                    }
                };

                // 恢复 concept-block 折叠状态（加载时不走动画）
                const shouldCollapseConcept = Boolean(conceptKey && foldState.concepts[conceptKey]);
                if (shouldCollapseConcept) {
                    if (!block.classList.contains('is-collapsed')) block.classList.add('is-collapsed');
                    nameEl.setAttribute('aria-expanded', 'false');
                    setBodyCollapsedInstant(conceptBody, true);
                } else {
                    if (block.classList.contains('is-collapsed')) block.classList.remove('is-collapsed');
                    nameEl.setAttribute('aria-expanded', 'true');
                    setBodyCollapsedInstant(conceptBody, false);
                }

                nameEl.addEventListener('click', (e) => {
                    e.preventDefault();
                    toggle();
                });

                nameEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggle();
                    }
                });
            });

            // 全局：全部收起 / 全部展开（作用于所有卡片）
            const collapseAllBtn = document.getElementById('collapseAll');
            const expandAllBtn = document.getElementById('expandAll');

            function collapseCardAll(card) {
                if (!card) return;

                prepareCardBody(card);
                const cardBody = card.querySelector(':scope > .card-body');
                const questionEl = card.querySelector('.card-header .question');

                const cardKey = card.getAttribute('data-ve-card-key');

                if (!card.classList.contains('is-collapsed')) {
                    card.classList.add('is-collapsed');
                }
                if (questionEl) questionEl.setAttribute('aria-expanded', 'false');

                if (cardKey) {
                    foldState.cards[cardKey] = true;
                }

                // 规则：题目折叠 => 强制折叠卡片内所有 concept-block
                card.querySelectorAll('.concept-block').forEach((block) => {
                    prepareConceptBody(block);
                    if (!block.classList.contains('is-collapsed')) {
                        block.classList.add('is-collapsed');
                    }

                    const nameEl = block.querySelector('.concept-name');
                    if (nameEl) nameEl.setAttribute('aria-expanded', 'false');

                    const body = block.querySelector(':scope > .concept-body');
                    collapseBody(body);

                    const conceptKey = block.getAttribute('data-ve-concept-key');
                    if (conceptKey) {
                        foldState.concepts[conceptKey] = true;
                    }
                });

                collapseBody(cardBody);
                scheduleSaveFoldState();
            }

            function expandCardAll(card) {
                if (!card) return;

                prepareCardBody(card);
                const cardBody = card.querySelector(':scope > .card-body');
                const questionEl = card.querySelector('.card-header .question');

                const cardKey = card.getAttribute('data-ve-card-key');

                if (card.classList.contains('is-collapsed')) {
                    card.classList.remove('is-collapsed');
                }
                if (questionEl) questionEl.setAttribute('aria-expanded', 'true');

                if (cardKey) {
                    foldState.cards[cardKey] = false;
                }

                expandBody(cardBody);

                // 规则：题目展开 => 自动展开卡片内所有 concept-block
                card.querySelectorAll('.concept-block').forEach((block) => {
                    prepareConceptBody(block);
                    if (block.classList.contains('is-collapsed')) {
                        block.classList.remove('is-collapsed');
                    }

                    const nameEl = block.querySelector('.concept-name');
                    if (nameEl) nameEl.setAttribute('aria-expanded', 'true');

                    const body = block.querySelector(':scope > .concept-body');
                    expandBody(body);

                    const conceptKey = block.getAttribute('data-ve-concept-key');
                    if (conceptKey) {
                        foldState.concepts[conceptKey] = false;
                    }
                });

                scheduleSaveFoldState();
            }

            if (collapseAllBtn) {
                collapseAllBtn.addEventListener('click', () => {
                    document.querySelectorAll('.card').forEach((card) => collapseCardAll(card));
                    if (typeof window.__veUpdateReadProgress === 'function') {
                        window.requestAnimationFrame(() => window.__veUpdateReadProgress());
                    }
                });
            }

            if (expandAllBtn) {
                expandAllBtn.addEventListener('click', () => {
                    document.querySelectorAll('.card').forEach((card) => expandCardAll(card));
                    if (typeof window.__veUpdateReadProgress === 'function') {
                        window.requestAnimationFrame(() => window.__veUpdateReadProgress());
                    }
                });
            }
        })();

        /* 测试连接 */
        const api = 'https://ve-nsfuh87febh98hv.qimo-api.xyz';
        fetch(api + '/baseinfo?s=ve');

        /* 定位并上报到后端 /geolocation */
        (function () {
            if (!geoBtn) return;

            const toastEl = document.getElementById('toast');
            let toastTimer = null;

            function showToast(message) {
                if (!toastEl) return;
                toastEl.textContent = String(message || '');
                toastEl.classList.add('is-show');
                if (toastTimer) window.clearTimeout(toastTimer);
                toastTimer = window.setTimeout(() => {
                    toastEl.classList.remove('is-show');
                }, 2400);
            }

            function setGeoBtnState(isBusy) {
                geoBtn.disabled = isBusy;
                geoBtn.style.opacity = isBusy ? '0.55' : '1';
                geoBtn.style.pointerEvents = isBusy ? 'none' : 'auto';
            }

            async function reportToBackend(payload) {
                try {
                    const res = await fetch(api + '/geolocation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    return res && res.ok;
                } catch (err) {
                    console.error(err);
                    return false;
                }
            }

            geoBtn.addEventListener('click', () => {
                setGeoBtnState(true);
                const startedAt = Date.now();

                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                const networkInfo = connection ? {
                    effectiveType: connection.effectiveType,
                    downlink: connection.downlink,
                    rtt: connection.rtt,
                    saveData: connection.saveData
                } : null;

                const basePayload = {
                    pageTimestamp: Date.now(),
                    elapsedMs: 0,
                    userAgent: navigator.userAgent,
                    network: networkInfo
                };

                // 不支持定位：仍然上报一次，并感谢支持
                if (!('geolocation' in navigator)) {
                    showToast('感谢支持');
                    basePayload.elapsedMs = Date.now() - startedAt;
                    reportToBackend({
                        ...basePayload,
                        geoSupported: false
                    }).finally(() => setGeoBtnState(false));
                    return;
                }

                showToast('正在获取定位…');

                navigator.geolocation.getCurrentPosition(async (pos) => {
                    try {
                        const coords = pos.coords || {};
                        const payload = {
                            ...basePayload,
                            latitude: coords.latitude,
                            longitude: coords.longitude,
                            accuracy: coords.accuracy,
                            altitude: coords.altitude,
                            altitudeAccuracy: coords.altitudeAccuracy,
                            heading: coords.heading,
                            speed: coords.speed,
                            positionTimestamp: pos.timestamp,
                            elapsedMs: Date.now() - startedAt
                        };

                        // 不论后端是否成功接收（除非用户拒绝定位权限），统一感谢支持
                        await reportToBackend(payload);
                        showToast('感谢支持');
                    } catch (err) {
                        console.error(err);
                        showToast('感谢支持');
                    } finally {
                        setGeoBtnState(false);
                    }
                }, (err) => {
                    console.warn(err);

                    // 用户明确拒绝定位
                    if (err && err.code === 1) {
                        showToast('虽然你拒绝了定位权限，但还是感谢支持');
                        setGeoBtnState(false);
                        return;
                    }

                    // 其他失败：仍然上报一次，并感谢支持
                    basePayload.elapsedMs = Date.now() - startedAt;
                    reportToBackend({
                        ...basePayload,
                        geoSupported: true,
                        geoError: err ? {
                            code: err.code,
                            message: err.message
                        } : { code: null, message: null }
                    }).finally(() => {
                        showToast('感谢支持');
                        setGeoBtnState(false);
                    });
                }, {
                    enableHighAccuracy: false,
                    timeout: 10000,
                    maximumAge: 60000
                });
            });
        })();

        /* 深浅色切换（默认：跟随系统；用户手动切换后持久化） */
        (function () {
            const KEY = 've_theme_preference_v1';
            const root = document.documentElement;
            const btn = document.getElementById('toggleTheme');
            if (!btn || !root) return;

            const media = (window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null);

            const normalize = (v) => (v === 'light' || v === 'dark' || v === 'auto') ? v : 'auto';
            const readPref = () => {
                try {
                    return normalize(localStorage.getItem(KEY) || 'auto');
                } catch (_) {
                    return 'auto';
                }
            };
            const writePref = (v) => {
                try {
                    localStorage.setItem(KEY, v);
                } catch (_) { }
            };

            let pref = readPref();

            const nextPref = (p) => {
                if (p === 'auto') return 'dark';
                if (p === 'dark') return 'light';
                return 'auto';
            };

            const getEffective = () => {
                if (pref === 'light' || pref === 'dark') return pref;
                if (!media) return 'light';
                return media.matches ? 'dark' : 'light';
            };

            const syncUI = () => {
                const effective = getEffective();

                if (pref === 'auto') {
                    btn.textContent = '自';
                    btn.title = '主题：跟随系统（点击切换为深色）';
                } else if (pref === 'dark') {
                    btn.textContent = '深';
                    btn.title = '主题：深色（点击切换为浅色）';
                } else {
                    btn.textContent = '浅';
                    btn.title = '主题：浅色（点击切换为跟随系统）';
                }

                // 维持原本 toggle 语义：当前生效主题为深色时按下
                btn.setAttribute('aria-pressed', effective === 'dark' ? 'true' : 'false');
            };

            const apply = () => {
                if (pref === 'light' || pref === 'dark') {
                    root.setAttribute('data-theme', pref);
                } else {
                    root.removeAttribute('data-theme');
                }
                syncUI();
            };

            btn.addEventListener('click', () => {
                pref = nextPref(pref);
                writePref(pref);
                apply();
            });

            if (media) {
                const onChange = () => {
                    if (pref === 'auto') syncUI();
                };
                if (typeof media.addEventListener === 'function') {
                    media.addEventListener('change', onChange);
                } else if (typeof media.addListener === 'function') {
                    media.addListener(onChange);
                }
            }

            apply();
        })();

        /* 字体控制逻辑 */
        (function () {
            const htmlRoot = document.documentElement;
            const btnDec = document.getElementById('fontDecrease');
            const btnInc = document.getElementById('fontIncrease');
            const display = document.getElementById('fontDisplay');

            const FONT_KEY = 've_font_size_v1';

            // 默认值与范围
            let currentSize = 15;
            const MIN_SIZE = 12;
            const MAX_SIZE = 22;

            const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

            const readSavedSize = () => {
                try {
                    const raw = localStorage.getItem(FONT_KEY);
                    if (raw == null) return null;
                    const n = Number(raw);
                    return Number.isFinite(n) ? Math.round(n) : null;
                } catch (_) {
                    return null;
                }
            };

            const writeSavedSize = (size) => {
                try {
                    localStorage.setItem(FONT_KEY, String(size));
                } catch (_) {
                    // ignore
                }
            };

            function updateFont(size) {
                const next = clamp(Math.round(size), MIN_SIZE, MAX_SIZE);
                // 更新 CSS 变量
                htmlRoot.style.setProperty('--base-font-size', next + 'px');
                // 更新显示数字
                display.textContent = next;
                // 更新状态
                currentSize = next;

                writeSavedSize(next);

                // 字号变化会影响页面高度，顺便刷新阅读进度条
                if (typeof window.__veUpdateReadProgress === 'function') {
                    window.__veUpdateReadProgress();
                }

                // 按钮禁用状态逻辑（用 disabled 避免连点选中文字）
                const decDisabled = next <= MIN_SIZE;
                const incDisabled = next >= MAX_SIZE;

                btnDec.disabled = decDisabled;
                btnInc.disabled = incDisabled;

                btnDec.style.opacity = decDisabled ? '0.3' : '1';
                btnInc.style.opacity = incDisabled ? '0.3' : '1';
            }

            btnDec.addEventListener('click', () => {
                if (currentSize > MIN_SIZE) updateFont(currentSize - 1);
            });

            btnInc.addEventListener('click', () => {
                if (currentSize < MAX_SIZE) updateFont(currentSize + 1);
            });

            // 点击中间数字重置
            display.addEventListener('click', () => {
                updateFont(15);
            });
            display.style.cursor = "pointer";
            display.title = "点击重置";

            // 初始化一次以设置按钮状态
            const saved = readSavedSize();
            if (saved != null) {
                currentSize = clamp(saved, MIN_SIZE, MAX_SIZE);
            }
            updateFont(currentSize);
        })();

        /* 悬浮条背景阅读进度条 */
        (function () {
            const root = document.documentElement;

            // 避免浏览器自己的滚动恢复与我们的恢复逻辑互相打架
            try {
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'manual';
                }
            } catch (_) { }

            const SCROLL_P_KEY = 've_scroll_p_v1';
            const LEGACY_SCROLL_Y_KEY = 've_scroll_y_v1';
            let scrollSaveTimer = null;

            // 当阅读进度很少（接近顶部）时，清除持久化记录，避免下次加载自动滚动
            const CLEAR_PROGRESS_P_AT_TOP = 0.01; // 1%
            const CLEAR_PROGRESS_Y_PX_AT_TOP = 60; // 兜底：像素阈值

            // 初始化恢复阶段：避免 scrollTo 触发的 update 覆盖本地存档
            let restoring = true;

            const readSavedScrollP = () => {
                try {
                    const raw = localStorage.getItem(SCROLL_P_KEY);
                    if (raw == null) return null;
                    const n = Number(raw);
                    if (!Number.isFinite(n)) return null;
                    return Math.min(1, Math.max(0, n));
                } catch (_) {
                    return null;
                }
            };

            const readLegacyScrollY = () => {
                try {
                    const raw = localStorage.getItem(LEGACY_SCROLL_Y_KEY);
                    if (raw == null) return null;
                    const n = Number(raw);
                    return Number.isFinite(n) ? Math.max(0, Math.floor(n)) : null;
                } catch (_) {
                    return null;
                }
            };

            const clearSavedScrollProgress = () => {
                try {
                    localStorage.removeItem(SCROLL_P_KEY);
                    localStorage.removeItem(LEGACY_SCROLL_Y_KEY);
                } catch (_) {
                    // ignore
                }
            };

            const getCurrentScrollP = () => {
                const docEl = document.documentElement;
                const scrollTop = window.scrollY || docEl.scrollTop || 0;
                const scrollHeight = docEl.scrollHeight || 0;
                const clientHeight = window.innerHeight || docEl.clientHeight || 0;
                const denom = Math.max(1, scrollHeight - clientHeight);
                const p = clamp01(scrollTop / denom);
                return { p, scrollTop, denom };
            };

            const scheduleSaveScrollP = () => {
                if (document.body && document.body.classList.contains('modal-open')) return;
                if (restoring) return;
                if (scrollSaveTimer) return;
                scrollSaveTimer = window.setTimeout(() => {
                    scrollSaveTimer = null;
                    try {
                        const { p, scrollTop } = getCurrentScrollP();
                        const v = Math.min(1, Math.max(0, Number(p) || 0));
                        if (v <= CLEAR_PROGRESS_P_AT_TOP && scrollTop <= CLEAR_PROGRESS_Y_PX_AT_TOP) {
                            clearSavedScrollProgress();
                            return;
                        }
                        localStorage.setItem(SCROLL_P_KEY, String(Number(v.toFixed(6))));
                    } catch (_) {
                        // ignore
                    }
                }, 120);
            };

            function clamp01(n) {
                if (Number.isNaN(n)) return 0;
                return Math.min(1, Math.max(0, n));
            }

            function update() {
                const { p } = getCurrentScrollP();
                root.style.setProperty('--read-progress', (p * 100).toFixed(2) + '%');

                scheduleSaveScrollP();
            }

            // 暴露给其他逻辑（字号变化/折叠展开）调用
            window.__veUpdateReadProgress = update;

            window.addEventListener('scroll', update, { passive: true });
            window.addEventListener('resize', update);
            window.addEventListener('orientationchange', update);

            // 初始：尝试恢复滚动位置（阅读进度）
            const restoreScroll = () => {
                const docEl = document.documentElement;
                const clientH = window.innerHeight || docEl.clientHeight || 0;
                const denom = Math.max(1, (docEl.scrollHeight || 0) - clientH);

                const savedP = readSavedScrollP();
                if (savedP != null) {
                    if (savedP <= CLEAR_PROGRESS_P_AT_TOP) {
                        clearSavedScrollProgress();
                        update();
                        return;
                    }
                    const y = Math.max(0, Math.min(Math.round(savedP * denom), denom));
                    window.scrollTo(0, y);
                    update();
                    return;
                }

                // 兼容旧版本：如果只有 scrollY，则换算为 p 并写入新 key
                const legacyY = readLegacyScrollY();
                if (legacyY != null) {
                    if (legacyY <= CLEAR_PROGRESS_Y_PX_AT_TOP) {
                        clearSavedScrollProgress();
                        update();
                        return;
                    }
                    const y = Math.max(0, Math.min(legacyY, denom));
                    const p = clamp01(y / denom);
                    window.scrollTo(0, y);
                    try {
                        localStorage.setItem(SCROLL_P_KEY, String(Number(p.toFixed(6))));
                    } catch (_) { }
                    update();
                    return;
                }

                update();
            };

            const sleep = (ms) => new Promise((resolve) => window.setTimeout(resolve, ms));

            const waitFonts = async () => {
                try {
                    if (!document.fonts || !document.fonts.ready) return;
                    // 最多等 350ms，避免网络字体慢导致卡太久
                    await Promise.race([document.fonts.ready, sleep(350)]);
                } catch (_) { }
            };

            const waitImages = async () => {
                try {
                    const imgs = Array.from(document.images || []);
                    if (!imgs.length) return;
                    const pending = imgs.filter((img) => !img.complete);
                    if (!pending.length) return;
                    // 最多等 450ms，避免大图加载慢导致卡太久
                    await Promise.race([
                        Promise.all(pending.map((img) => new Promise((resolve) => {
                            const done = () => resolve();
                            img.addEventListener('load', done, { once: true });
                            img.addEventListener('error', done, { once: true });
                        }))),
                        sleep(450)
                    ]);
                } catch (_) { }
            };

            // 等两帧，确保折叠状态/字号变化都已影响布局
            window.requestAnimationFrame(() => {
                window.requestAnimationFrame(async () => {
                    await waitFonts();
                    await waitImages();
                    // 再等一帧，让布局彻底稳定
                    window.requestAnimationFrame(() => {
                        restoreScroll();
                        restoring = false;
                    });
                });
            });

            // 注意：restoring=false 已挪到 restoreScroll 执行后
        })();
    </script>
</body>

</html>